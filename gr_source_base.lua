require "source_aux"

local coroutine    = coroutine
local ipairs       = ipairs
local setmetatable = setmetatable
local string       = string

--- <p>Basis-Klasse aller
--  <a href="/modules/source.html">source</a>-Objekte</p>
--  <p><a href="/modules/source.html">source</a>-Objekte
--  k&ouml;nnen auf zwei Arten
--  verwendet werden:  Es sei <code>s</code> ein derartiges
--  <a href="/modules/source.html">source</a>-Objekt:
--  <ul>
--   <li><p>als Iterator in <code>for</code>-Schleifen; etwa so:</p>
--   <pre class="example">
--  for v in s<br/>
--  do  -- do something with v which<br/>
--      -- is generated by the<br/>
--      -- source-object s<br/>
--  end<br/>
--   </pre></li>
--  <li>als Acceptor. Acceptoren setzen das Concept des
--  abstrakten Automaten um.  Der Zustands- und der
--  Zustands&uuml;berf&uuml;hrungsfunktion entsprechen hier die
--  Routinen <a href="/modules/source.html#cur">source.cur</a> und <a href="/modules/source.html#next">source.next</a>.</li>
--  </ul></p>
module "source"

--- <p>wird in metatables dem Schl&uuml;ssel <code>"_call"</code>
--     zugewiesen.<br/>
--  ... bewirkt dann, da&szlig; mit dieser metatable dekorierte
--      table zum Iterator wird, der in for-Schleifen verwendet
--      werden kann.</p>
--
--      <p>Sollte nicht direkt, sondern indirekt mit Hilfe von
--      <a href="/modules/source.html#new">source.new</a> aufgerufen werden.</p>
function __call(f, s, v)
 local ret, val = coroutine.resume(f.co)
 if     not(ret and val)
 then   return nil
 end
 return val
end

--- <p>erzeugt genau ein Objekt der
--  <a href="/modules/source.html">source</a>-Klasse.<p>
--  @return das Objekt der <a href="/modules/source.html">source</a>-Klasse
--  @param co eine Coroutine.  Sie erzeugt mit <code>yield</code>
--  all die Dinge, die das mit <code>source:new(co)</code> erzeugte
--  <a href="/modules/source.html">source</a>-Objekt von sich gibt.
function new(self, co)
 local ret = {
  cur_ch,
  co = co }
 local mt  = {
  __call  = __call,
  __index = self }
 setmetatable(ret, mt)
 return ret
end

--- <p>liefert aktuelles Ding am dem
--  <a href="/modules/source.html">source</a>-Objekt
--  <code>self</code> entsprechenden Acceptors zur&uuml;ck.</p>
--  <p>Bevor diese Funktion aufgerufen wird, mu&szlig; sichergestellt
--     sein, da&szlig; <a href="/modules/source.html#next">source.next</a>
--     wenigstens einmal vorher aufgerufen wurde.</p>
--  <p>Desweiteren sollte <a href="/modules/source.html#cur">source.cur</a>
--     nicht aufgerufen werden, wenn der vorangegangene Aufruf von
--     <a href="/modules/source.html#next">source.next</a> die Zeichenkette
--     <code>"stop"</code> ergab.</p>
--  @return das Ding am <code>self</code> entsprechenden Acceptor
function cur(self)
 return self.cur_ch
end

--- <p>r&uuml;ckt den dem <a href="/modules/source.html">source</a>-Objekt
--  <code>self</code> entsprechenden Acceptor ein Zeichen weiter.</p>
--  @return genau eine Zeichenkette:
--  <ul>
--   <li>Zeichenkette <code>"stop"</code>: kein Zeichen mehr vorhanden</li>
--   <li>Zeichenkette <code>"go"</code>: sonst</li>
--  </ul>
function next(self)
 local ret
 ret, self.cur_ch = coroutine.resume(self.co)
 if     (ret and self:cur())
 then   return "go"
 else   return "stop"
 end
end
